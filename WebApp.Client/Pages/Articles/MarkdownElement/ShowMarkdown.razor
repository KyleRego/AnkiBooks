@using AnkiBooks.ApplicationCore.Entities
@using AnkiBooks.ApplicationCore.Interfaces
@using AnkiBooks.ApplicationCore.Services

@using AnkiBooks.WebApp.Client.Services

@using AnkiBooks.WebApp.Client.Pages.Articles.EditArticleElement

@inject DraggedItemHolder<ArticleElement> draggedItemHolder
@inject IMarkdownContentService MarkdownContentService

@if (Editing == true)
{
    <EditMarkdown StartingMarkdown="@MarkdownContent" @bind-Editing="@Editing" />
}
else
{
<div    class="@(nestedDragLevels != 0 ? "dragover-highlight" : "")"
        @ondragenter="HandleDragEnter"
        @ondragenter:preventDefault
        ondragover="event.preventDefault();"
        @ondragleave="HandleDragLeave"
        @ondragleave:preventDefault
        @ondrop="HandleDrop">

    @if (ReadMode == false)
    {
    <div class="float-right">
        <div class="mb-1 ml-1 p-1 border-primary-thin d-flex flex-row justify-content-between align-items-center">
            <div class="w-5 h-5" role="button"
                @onclick="BeginEditing">
                <Edit />
            </div>

            <div class="w-6 h-6 ml-2" role="button"
                draggable="true"
                @ondragstart="HandleDrag"
                @ondragend="HandleDragEnd">
                <Drag />
            </div>

            <div class="w-5 h-5 ml-2" role="button">
                <Delete />
            </div>
        </div>
    </div>
    }

    <RenderMarkdown Text="@MarkdownContent.Text" />
</div>
}

@code {
    [Parameter]
    public MarkdownContent MarkdownContent { get; set; } = null!;

    [Parameter]
    public OrderedElementsContainer<ArticleElement> ElementsContainer { get; set; } = null!;

    [Parameter]
    public EventCallback<OrderedElementsContainer<ArticleElement>> ElementsContainerChanged { get; set; }

    [CascadingParameter(Name="ReadMode")]
    public bool ReadMode { get; set; }

    public bool Editing { get; set; } = false;

    private void BeginEditing()
    {
        Editing = true;
    }

    private void HandleDrag()
    {
        draggedItemHolder.DraggedItem = MarkdownContent;
    }

    private void HandleDragEnd()
    {
        draggedItemHolder.DraggedItem = null;
    }

    private int nestedDragLevels = 0;

    private void HandleDragEnter()
    {
        ArticleElement? draggedItem = draggedItemHolder.DraggedItem;

        if (draggedItem == null) return;
        if (draggedItem == MarkdownContent) return;
        nestedDragLevels += 1;
    }

    private void HandleDragLeave()
    {
        ArticleElement? draggedItem = draggedItemHolder.DraggedItem;

        if (draggedItem == null) return;
        if (draggedItem == MarkdownContent) return;
        nestedDragLevels -= 1;
    }

    private async Task HandleDrop()
    {
        @* nestedDragLevels = 0;
        ArticleElement? droppedItem = draggedItemHolder.DraggedItem;

        if (droppedItem == null) return;
        if (droppedItem == MarkdownContent) return;

        droppedItem.OrdinalPosition = MarkdownContent.OrdinalPosition;

        ArticleElement? updatedItem = await ApiService.PutElement(droppedItem);
        ArgumentNullException.ThrowIfNull(updatedItem);

        ElementsContainer.UpdatePosition(droppedItem);
        await ElementsContainerChanged.InvokeAsync(ElementsContainer); *@
    }
}
