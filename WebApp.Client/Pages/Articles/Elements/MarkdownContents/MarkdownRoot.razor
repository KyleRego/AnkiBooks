@using AnkiBooks.ApplicationCore.Entities
@using AnkiBooks.ApplicationCore.Interfaces
@using AnkiBooks.ApplicationCore.Services

@using AnkiBooks.WebApp.Client.Services

@inject DraggedItemHolder<ArticleElement> draggedItemHolder
@inject IArticleElementService ArticleElementService

@if (Editing == true)
{
    <EditMarkdown InitialArticleElement="@MarkdownContent" @bind-Editing="@Editing" />
}
else
{
<div    class="@(nestedDragLevels != 0 ? "dragover-highlight" : "")"
        @ondragenter="HandleDragEnter"
        @ondragenter:preventDefault
        ondragover="event.preventDefault();"
        @ondragleave="HandleDragLeave"
        @ondragleave:preventDefault
        @ondrop="HandleDrop">

    <div class="float-right">
        @if (showingOptions == false)
        {
            <div class="d-flex flex-row justify-content-start">
                <div class="w-5 h-5 mr-2" role="button" title="Edit markdown" @onclick="BeginEditing">
                    <Edit />
                </div>

                <div role="button" class="w-5 h-5" title="Options" @onclick="ShowOptions">
                    <Gear />
                </div>
            </div>
        }
        else
        {
            <div class="position-relative top-4 right-4 px-2 border-primary">
                <ul>
                    <li class="my-2" draggable="true" @ondrag="HandleDrag">Drag element</li>
                    <li class="my-2">Delete markdown</li>
                </ul>
            </div>
        }
    </div>

    <RenderMarkdown Text="@MarkdownContent.Text" />
</div>
}

@code {
    private bool showingOptions = false;

    private void ShowOptions()
    {
        showingOptions = true;
    }

    [Parameter]
    public MarkdownContent MarkdownContent { get; set; } = null!;

    [Parameter]
    public OrderedElementsContainer<ArticleElement> ElementsContainer { get; set; } = null!;

    [Parameter]
    public EventCallback<OrderedElementsContainer<ArticleElement>> ElementsContainerChanged { get; set; }

    public bool Editing { get; set; } = false;

    private void BeginEditing()
    {
        Editing = true;
    }

    private void HandleDrag()
    {
        draggedItemHolder.DraggedItem = MarkdownContent;
    }

    private void HandleDragEnd()
    {
        draggedItemHolder.DraggedItem = null;
    }

    private int nestedDragLevels = 0;

    private void HandleDragEnter()
    {
        ArticleElement? draggedItem = draggedItemHolder.DraggedItem;

        if (draggedItem == null) return;
        if (draggedItem == MarkdownContent) return;
        nestedDragLevels += 1;
    }

    private void HandleDragLeave()
    {
        ArticleElement? draggedItem = draggedItemHolder.DraggedItem;

        if (draggedItem == null) return;
        if (draggedItem == MarkdownContent) return;
        nestedDragLevels -= 1;
    }

    private async Task HandleDrop()
    {
        nestedDragLevels = 0;
        ArticleElement? droppedItem = draggedItemHolder.DraggedItem;

        if (droppedItem == null) return;
        if (droppedItem == MarkdownContent) return;

        droppedItem.OrdinalPosition = MarkdownContent.OrdinalPosition;

        ArticleElement? updatedItem = (ArticleElement?)await ArticleElementService.PutArticleElement(droppedItem);
        ArgumentNullException.ThrowIfNull(updatedItem);

        ElementsContainer.UpdatePosition(droppedItem);
        await ElementsContainerChanged.InvokeAsync(ElementsContainer);
    }
}
