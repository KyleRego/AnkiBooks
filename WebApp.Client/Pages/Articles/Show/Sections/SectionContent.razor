@using AnkiBooks.ApplicationCore.Entities
@using System.Text.Json
@using AnkiBooks.ApplicationCore.Interfaces
@using AnkiBooks.WebApp.Client.Services
@using AnkiBooks.WebApp.Client.Shared.Heroicons
@inject IAnkiBooksApiService ApiService
@inject DragStateService dragState
@inject ILogger<SectionContent> logger

@if (editing == false)
{
    <div class="d-flex flex-row">
        <div class="min-w-0 flex-grow-1
                        @(nestedDragLevels != 0 ? "highlight-dropzone" : "")"

                        @ondragend="HandleDragEnd"
                        @ondragenter="HandleDragEnter" @ondragenter:preventDefault
                        ondragover="event.preventDefault();"
                        @ondragleave="HandleDragLeave" @ondragleave:preventDefault
                        @ondrop="HandleDrop">
            <div class="float-right d-flex align-items-center mr-4">
                <div class="w-6 h-6" role="button" @onclick="BeginEditing">
                    <Edit />
                </div>

                <div class="w-6 h-6 ml-4" role="button"
                                draggable="true"
                                @ondragstart="HandleDrag">
                    <Drag />
                </div>

                <div class="w-6 h-6 ml-4" role="button" @onclick="DeleteElement">
                    <Delete />
                </div>
            </div>

            <RenderMarkdown Text="@Section.Text" />
        </div>
    </div>
 }
else
{
    <EditSection StartingSection="@Section" @bind-Editing="@editing" />
}

@code {
    [Parameter]
    public Section Section { get; set; } = null!;

    [Parameter]
    public OrderedElementsContainer OrderedSectionsContainer { get; set; } = null!;

    [Parameter]
    public EventCallback<OrderedElementsContainer?> OrderedSectionsContainerChanged { get; set; }

    private bool editing = false;

    private void BeginEditing()
    {
        editing = true;
    }

    private async Task DeleteElement()
    {
        await ApiService.DeleteSection(Section.Id);

        OrderedSectionsContainer.Remove(Section);
        await OrderedSectionsContainerChanged.InvokeAsync(OrderedSectionsContainer);
    }

    private void HandleDrag()
    {
        logger.LogInformation("drag");
        dragState.DraggedElement = Section;
    }

    private void HandleDragEnd()
    {
        logger.LogInformation("dragend");
        dragState.DraggedElement = null;
    }

    private int nestedDragLevels = 0;

    private void HandleDragEnter()
    {
        IOrderedElement? draggedElement = dragState.DraggedElement;

        if (draggedElement == null) return;
        if (draggedElement == Section) return;
        logger.LogInformation("dragenter");
        nestedDragLevels += 1;
    }

    private void HandleDragLeave()
    {
        IOrderedElement? draggedElement = dragState.DraggedElement;

        if (draggedElement == null) return;
        if (draggedElement == Section) return;
        logger.LogInformation("dragleave");

        nestedDragLevels -= 1;
    }

    private async Task HandleDrop()
    {
        nestedDragLevels = 0;
        logger.LogInformation("drop");
        IOrderedElement? droppedElement = dragState.DraggedElement;

        if (droppedElement == null) return;
        if (droppedElement == Section) return;

        int ordinalPositionBefore = droppedElement.OrdinalPosition;
        droppedElement.OrdinalPosition = Section.OrdinalPosition;
        // TODO: Fix drag and drop stuff
        @* await ApiService.PutSection(droppedElement); *@

        OrderedSectionsContainer.UpdatePosition(droppedElement);
        await OrderedSectionsContainerChanged.InvokeAsync(OrderedSectionsContainer);
    }
}
